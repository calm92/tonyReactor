0.面向对象模型
    程序采用面向对象的方法，通过定义一个基类Protocol,并且定义其中的三个函数为虚函数：
```
        virtual void dataReceived(std::string data);
	virtual void connectionMade() ;
	virtual void connectionLost() ;
```
    通c++多态的特性，让用户继承Protocol并且重写三个虚函数，从而达到用户自己定制所需要的业务逻辑。
    由于c++不支持类参数的传递，所以采用模板的方式，来写Reactor,从而间接得到用户的继承类。
    但是这样就存在一个问题，每次更改业务层的逻辑的时候，整个程序都需要重新编译。


1.多线程模型  
    程序采用多线程模型，主线程负责accept新的连接，然后将新的连接分配给各个子线程。子线程负责读写自己所负责的连接。这里为了实现主线程和子线程之间的无锁通信，采用以下方法：
　　主线程建立子线程的epoll文件描述符，然后主线程保存各个子线程的epfd，当有新连接时，主线程从连接池中得到一个可用的Protocol并对它进行初始化，然后选择一个子线程的epfd，为这个epfd中加入监听事件。采用这种机制，对于主线程和子线程的任务分配就可以实现无锁。
　　对于需要关闭连接时，主要进行两个操作：1.close连接。2.进行连接池protocolMaster的资源回收。
　　对于close连接，不存在竞争。但是连接池的资源回收，如果在多个线程中进行，会有竞争存在。所以放弃各个子线程进行连接池的资源回收这一步。
　　考虑统一在主线程中，进行连接池的资源回收和连接池中得到可用连接这一操作，此时，就不会出现竞争。所以子线程关闭连接时，需要通过一定的方法来通知主线程，进行此连接的连接池资源回收操作。这里不能用消息队列等需要锁的方式。考虑到主线程和子线程都具有网络通信，而且都是使用epoll，所以采用一下方法：
　　在主线程中，监听两个端口，一个为外部客户端的连接监听端口，另一个则为主线程监听子线程的消息的端口。当子线程需要关闭一个连接时，子线程进行close操作之后，向主线程监听的端口发送一个protocol(连接实例)的index，则主线程可以通过这个index来找到对应的连接实例，从而进行连接池的资源回收。考虑到同一主机之间进行socket通信是不走网卡的，所以效率肯定会高于有锁模型。
　　通过上述方法，就可以做到多线程的无锁模型。

2.线程负载均衡
    由于主线程负责监听和关闭连接时的回收工作，所以主线程可以知道所有线程的实时连接数，通过这个信息，就可以实现简单的负载均衡。即对于每次到来的新连接，将文件描述符传递给连接数最少的线程。

3.定时器
    定时器任务统一由主线程来执行。这样就不可避免的会有锁。主要体现在：子线程中进行事件注册和主线程中通过注册事件的最小堆来获得超时事件。考虑到主线程在执行超时事件的时候，可能需要较长的事件，如果这段时间中，主线程一直拿着锁，则子线程可能会较长时间的阻塞在这上面。所以采用如下方法，来使主线程得到互斥锁的时间尽量短：通过在定时器中维护一个超时事件的队列，来缩短主线程获得锁的时间。具体做法如下：主线程进行定时器任务时，当得到一个超时任务，它不马上执行超时事件，而是把超市事件加入队列中，然后查看下一个注册事件是否超时。当最小堆最上面的事件没有超时时，就释放锁。然后再具体的执行超时事件任务。



